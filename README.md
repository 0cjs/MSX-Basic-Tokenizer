# MSX Basic Tokenizer  
v1.0

Convert MSX Basic ASCII programs to tokenized format.  

### How to use

`msxbatoken.py <source> [destination] [-sl] [-bw <1-32>] [-vb <0-3>] [-fb]`  

If `destination` is not given, the file will be saved as `source` with a `.bas` extension.  
(Might overwrite the source. Use `.asc` for ASCII Basic listings.)  

`-sl`  
*Save List:*  
Saves an `.mlt` List file similar to the ones exported by assemblers with the tokens alongside the code and some statistics.  
> The `.mtl` file uses the same [MSX Sublime Tools](https://github.com/farique1/MSX-Sublime-Tools) syntax highlight as the MSX Basic.   

The format for each line is, ie:  
```
80da: ee80 7800 44 49 ef 50 49 f2 1f 41 31 41 59 26 53 60 00 00        120 DI=PI-3.1415926536  
```
-- The MSX Basic memory address of the line.  
-- The first four bytes with the next line address and the line number.  
-- The tokenized line.   
-- The line in ASCII Basic.  

`-bw  <1-32>`  
*Byte width:*  
The number of bytes shown (after the next line address and number) on the List on each line of tokenized code.  

`-vb <0-3>`  
*Verbose:*  
0 - Silent  
1 - Errors  
2 - Errors + Warnings  
3 - Errors + Warnings + Steps  

`-fb`  
*From Build:*  
Tells MSX Basic Tokenizer it is running from a build system an adjust some log output.  

### Notes

**MSX Basic Tokenizer** was tested with over 100 random basic programs from magazines and other sources and some programs crated to stress the conversions, however there still should be some (several?) fringe cases not covered.  
**Be careful.**  

There are some known discrepancies between **MSX Basic Tokenizer** and the MSX tokenization, most of them regarding errors on the code. They are:  
- MSX &b (binary notation) tokenizes anything after it as characters except when a tokenized command is reached. The implementation here only looks for 0 and 1, reverting back to the normal parsing on other characters.  
- Spaces at the end of a line (verified with PRINT and REM) are removed. The MSX does not remove it if loading from an `.asc` file (it is removed if typed on the machine.)  
- The MSX seems to split overflowed numbers on branching instructions (preceded by 0e), here it throw an error.  
- Syntax errors generate wildly different results from the ones generated by the MSX.  

Some errors on the code stop the conversion. They are:  
- Line number too high, Line number out of order, Lines not starting with numbers, Branching lines too high  
- Numbers bigger than their explicit type (in some cases they are converted up as per on the MSX)  


# openMSX Basic (de)Tokenizer

Uses  **openMSX**  to convert a basic program from ASCII to tokenized or vice-versa.

It calls  **openMSX**  headless (without screen) and with throttle, mount a path (current = default) as a disk, load a basic file from this path, saves it with the chosen format and closes  **openMSX**.

> Be careful with the folder used as a disk. openMSX respects the MSX disk limitations of size (size of all the files must not be greater than the emulated disk size) and file name sizes.  
> Always work on copies.

### How to use

On the Python code itself enter the location of your  **openMSX**  installation.  
Also optionally choose a machine and a extension.  
If no machine is specified the default one will be used.  
You can name a disk drive extension for machines without one. It will be plugged on the slot A by default but you can force it to slot B by writing  `:SlotB`  after its name.

```
openmsx_filepath = '/<path_to>/openmsx/openmsx.app'
machine_name = 'Sharp_HB-8000_1.2'
disk_ext_name = 'Microsol_Disk:SlotB'

```

> Leave the machine and extension variables blank (`''`) to use the  **openMSX**  defaults.

From the terminal call  `openmsxbatoken.py`:  
`openmsxbatoken.py <source> [destination] [-asc] [-vb]`

`source`  
*The file to convert.*  
If a path (absolute) is given, this path will be used to mount the disk on the MSX.  
If only a name is given the current path will be mounted as a disk on the MSX.

`destination`  
*The file to be saved.*  
If a path is given it will be ignored.  
If no name is given the  `source`  name will be used with a  `.bas`  or  `.asc`  extension accordingly.  
(Beware that the source CAN be overwritten).  

`-asc`  
*The format to save.*
Save the file in ASCII instead of tokenized.  
The default save extension will be changed to  `.asc`.

`-vb`  
*Verbose.*  
Displays the openMSX output.

### Known bugs

An  `autoexec.bas`  on the disk will run automatically and possibly prevent the conversion.  
There is a problem passing file names with some special characters, “&” for instance.  


# Helper Tools  

Some tools made to help develop and test the Tokenizer.  
> Their settings can be changed on the code itself. The variables are easily named and they are commented when needed.  

## Token Compare  

Convert ASCII listings with **MSXBatoken** and compares it with a conversion from **openMSXBatoken** (using a "real" MSX).  

## Token Format Viz

Format a tokenized MSX Basic program to display a line of basic per line of tokens.  
Also can interleave another tokenized file to compare them line by line.  
> Take command line arguments. See code.  

## Random Numbers  

Generate MSX Basic lines with random numbers of several types.  
Generate integer, single, double and scientific notation numbers.  

------------  
All made with Python 2.7  
Use with care.  